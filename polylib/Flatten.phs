---------------------------------------------------------------
-- Flatten
--   990527 Patrik Jansson
---------------------------------------------------------------
module Flatten(flatten,fflatten,fl_par,fl_rec,fl_all,singleton,nil) where
import Base(pmap,fmap2)

flatten :: Regular d => d a -> [a]
flatten  =  fflatten . fmap2 singleton flatten . out
-- flatten  =  cata (fflatten . fmap2 singleton id)

polytypic fflatten :: f [a] [a] -> [a]
  = case f of
      g + h     ->  fflatten `either` fflatten
      g * h     ->  \(x,y) -> fflatten x ++ fflatten y
      Empty     ->  nil
      Par       ->  id
      Rec       ->  id
      d @ g     ->  concat . flatten . pmap fflatten 
      Const t   ->  nil

fl_par :: Bifunctor f => f a b -> [a]
fl_rec :: Bifunctor f => f a b -> [b]
fl_all :: Bifunctor f => f a a -> [a]
fl_par = fflatten . fmap2 singleton nil
fl_rec = fflatten . fmap2 nil       singleton
fl_all = fflatten . fmap2 singleton singleton

---------------------------------------------------------------
-- Help functions for lists

singleton :: a -> [a]
singleton    x =  [x]
nil :: a -> [b]
nil    x =  []

{-
-- alternative definitions
polytypic fl_rec :: f a b -> [b]
  = case f of
      g + h     ->  fl_rec `either` fl_rec
      g * h     ->  \(x,y) -> fl_rec x ++ fl_rec y
      Empty     ->  nil
      Par       ->  nil
      Rec       ->  singleton
      d @ g     ->  concat . flatten . pmap fl_rec 
      Const t   ->  nil

polytypic fl_par :: f a [a] -> [a]
  = case f of
      g + h     ->  fl_par `either` fl_par
      g * h     ->  \(x,y) -> fl_par x ++ fl_par y
      Empty     ->  nil
      Par       ->  singleton
      Rec       ->  nil
      d @ g     ->  concat . flatten . pmap fl_par 
      Const t   ->  nil

-}
