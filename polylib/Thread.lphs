%% Literate PolyP + LaTeX script for use with lhs2TeX -*- Mode: latex; -*-
% ------------------------------------------------------------
% Threads a monad through a value
%   970424 Patrik Jansson  
% ------------------------------------------------------------

> module Thread(thread,pmapM,fthread,fmap2M) where
> import PolyPrelude
> import Base(cata,inn,pmap)
> import BaseM(pmapM,fmap2M,(@@))

%{
%align 21

> thread :: (Regular d, Monad m) => d (m a) -> m (d a)
> thread  =  cata (liftM inn . fthread)
> 
> polytypic fthread :: Monad m => f (m a) (m b) -> m (f a b)
>   = case f of
>       g + h       ->  sumthread  . (fthread -+- fthread)
>       g * h       ->  prodthread . (fthread -*- fthread)
>       Empty       ->  return
>       Par         ->  id
>       Rec         ->  id
>       d @ g       ->  thread     . (pmap fthread)
>       Const t     ->  return

%align
%}

> sumthread  :: Monad m => Either (m a) (m b) -> m (Either a b)
> sumthread  =  liftM Left `either` liftM Right
> 
> prodthread :: Monad m => (m a,m b) -> m (a,b)
> prodthread (mx,my) = mx >>= \x-> my >>= \y-> return (x,y)

% -------------------------------------------------------------
\paragraph{Monad operations} (that are not in PolyP's prelude)

> liftM :: Monad m => (a->b) -> m a -> m b
> liftM f mx = mx >>= \x -> return (f x)

Alternative definitions of |pmapM| and |fmap2M|:

%if not codeOnly

> pmapM :: (Regular d, Monad m) => (a -> m b) -> d a -> m (d b)
> pmapM f = thread . pmap f
> fmap2M :: (Bifunctor f, Monad m) => (a -> m c) -> (b -> m d) -> 
>                                     f a b -> m (f c d)
> fmap2M f g = fthread . fmap2 f g

%endif not codeOnly

