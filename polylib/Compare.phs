module Compare(pcompare,pcompareBy) where
import Base(fmap2)
import ConstructorName(fconstructor2Int)
import Flatten(flatten,fl_all)
import Zip(pzip,fzip,pzipWith')
pcompare :: (Regular d, Ord a) => d a -> d a -> Ordering
pcompare = pcompareBy compare
pcompareBy :: Regular d => (a->a->Ordering) -> 
                           d a -> d a -> Ordering
pcompareBy op x y = fcompare op (pcompareBy op) (out x) (out y)

fcompare :: Bifunctor f => (a->a->Ordering) -> (b->b->Ordering) -> 
                           f a b -> f a b -> Ordering
fcompare f g x y = 
  maybe (compare (fconstructor2Int x) (fconstructor2Int y))                
        (forder . fmap2 (uncurry f) (uncurry g))                           
        (fzip (x,y))                                        
forder :: Bifunctor f => f Ordering Ordering -> Ordering
forder = foldr ordop EQ . fl_all

ordop :: Ordering -> Ordering -> Ordering
ordop x y = case x of 
              EQ -> y
              _  -> x
