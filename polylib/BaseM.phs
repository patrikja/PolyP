---------------------------------------------------------------
-- Monadic polytypic functions
--   980504 Patrik Jansson
---------------------------------------------------------------
module BaseM(pmapM,fmapM,cataM,anaM,hyloM,paraM) where

pmapM :: (Regular d, Monad m) => (a -> m b) -> d a -> m (d b)
pmapM fM   = mapm inn . fmapM fM  (pmapM fM)   . out

polytypic fmapM :: Monad m => (a -> m c) -> (b -> m d) -> f a b -> m (f c d)
  = \p r -> case f of
	      g + h     ->  summapM  (fmapM p r) (fmapM p r)
	      g * h     ->  prodmapM (fmapM p r) (fmapM p r)
	      Empty     ->  return
	      Par       ->  p                     
	      Rec       ->  r                     
	      d @ g     ->  pmapM (fmapM p r)
	      Const t   ->  return                    


summapM :: Monad b => (a -> b c) -> (d -> b e) -> 
                      Either a d -> b (Either c e)
summapM f g = (mapm Left . f) `either` (mapm Right . g)
prodmapM :: Monad b => (a -> b c) -> (d -> b e) -> 
                       (a,d) -> b (c,e)
prodmapM  f g p = f (fst p) >>= \x-> g (snd p) >>= \y-> return (x,y) 
prodmapMr f g p = g (snd p) >>= \y-> f (fst p) >>= \x-> return (x,y) 

cataM :: Regular d => (FunctorOf d a b -> m b) -> (d a -> m b)
anaM  :: Regular d => (b -> m (FunctorOf d a b)) -> (b -> m (d a))
hyloM :: Bifunctor f => (f a b -> m b)-> (c -> m (f a c)) -> c -> m b
cataM iM    = iM      @@ fmapM idM (cataM iM   ) . out
anaM     oM = mapm inn . fmapM idM (anaM     oM) @@ oM
hyloM iM oM = iM      @@ fmapM idM (hyloM iM oM) @@ oM

-- new names for symmetry
idM :: Monad m => a -> m a
idM  = return
innM :: (Regular d, Monad m) => FunctorOf d a (d a) -> m (d a)
innM = idM . inn
innM :: (Regular d, Monad m) => d a -> m (FunctorOf d a (d a))
outM = idM . out
-- synonym
pmapMl = pmapM

paraM :: Regular d => (d a -> FunctorOf d a b -> m b) -> d a -> m b
paraM iM x = applyM (iM x) (fmapM idM (paraM iM) (out x))

-- Reverse order traversals
pmapMr :: (Regular d, Monad m) => (a -> m b) -> d a -> m (d b)
pmapMr fM   = mapm inn . fmapMr fM  (pmapMr fM)   . out

polytypic fmapMr :: Monad m => (a -> m c) -> (b -> m d) -> f a b -> m (f c d)
  = \p r -> case f of
	      g + h     ->  summapM   (fmapMr p r) (fmapMr p r)
	      g * h     ->  prodmapMr (fmapMr p r) (fmapMr p r)
	      Empty     ->  return
	      Par       ->  p                     
	      Rec       ->  r                     
	      d @ g     ->  pmapMr (fmapMr p r)
	      Const t   ->  return                    

cataMr iM    = iM      @@ fmapMr idM (cataMr iM   ) . out
anaMr     oM = mapm inn . fmapMr idM (anaMr     oM) @@ oM
hyloMr iM oM = iM      @@ fmapMr idM (hyloMr iM oM) @@ oM

----------------------------------------------------------------
-- Traversal either way: pmapM'
--   (True -> left to right, False -> right to left)

pmapM' :: (Regular d, Monad m) => Bool -> (a -> m b) -> d a -> m (d b)
pmapM' ord fM   = mapm inn . fmapM' ord fM  (pmapM' ord fM)   . out

polytypic fmapM' :: Monad m => Bool -> (a -> m c) -> (b -> m d) -> f a b -> m (f c d)
  = \ord p r -> case f of
      g + h     ->  summapM  (fmapM' ord p r) (fmapM' ord p r)
      g * h     ->  opM ord . (fmapM' ord p r -*- fmapM' ord p r)
      Empty     ->  return
      Par       ->  p                     
      Rec       ->  r                     
      d @ g     ->  pmapM' ord (fmapM' ord p r)
      Const t   ->  return                    

opM :: Monad m => Bool -> (m a, m b) -> m (a,b)
opM b p = case b of
            True  -> fst p >>= \x-> snd p >>= \y-> return (x,y) 
            False -> snd p >>= \y-> fst p >>= \x-> return (x,y) 

----------------------------------------------------------------
-- Monad operations (that are not in PolyPs prelude)

mapm :: Monad m => (a->b) -> m a -> m b
mapm f mx = mx >>= \x -> return (f x)
(@@) :: Monad m => (b->m c) -> (a->m b) -> (a->m c)
f @@ g = \y -> g y >>= f
