%% Literate PolyP + LaTeX script for use with lhs2TeX -*- Mode: latex; -*-
% ------------------------------------------------------------
% Comparing and ordering
%   000330 Patrik Jansson 
% ------------------------------------------------------------

> module Compare(pcompare',pcompare,fcompare) where
> import PolyPrelude

%if simulateInHaskell

> import PolyPTypes

%endif simulateInHaskell

> pcompare' :: (Regular d, Ord a) => d a -> d a -> Ordering
> pcompare' = pcompare compare

%{
%align 26

> pcompare :: Regular d    => (a->a->Ordering) -> d a -> d a -> Ordering
> pcompare eq x y = fcompare eq (pcompare eq) (out x) (out y)
> 
> polytypic fcompare :: (a->a->Ordering) -> (b->b->Ordering) -> 
>                       f a b -> f a b -> Ordering
>   = \p r -> case f of
>               g + h    ->  sumcompare  (fcompare p r) (fcompare p r)
>               g * h    ->  prodcompare (fcompare p r) (fcompare p r)
>               Empty    ->  \_ _ -> EQ
>               Par      ->  p
>               Rec      ->  r
>               d @ g    ->  pcompare (fcompare p r)
>               Const t  ->  compare 

%align
%}
%{
%align 47

> sumcompare :: (a->a->Ordering) -> (b->b->Ordering) -> 
>               Either a b -> Either a b -> Ordering
> sumcompare f g a b = case (a,b) of
>                        (Left  x, Left  v)   ->  f x v
>                        (Right y, Right w)   ->  g y w
>                        (Left  _, Right _)   ->  LT
>                        (Right _, Left  _)   ->  GT

%align
%}

> prodcompare :: (a->a->Ordering) -> (b->b->Ordering) -> 
>                (a,b)->(a,b) -> Ordering
> prodcompare f g p q = f (fst p) (fst q) `ordop` g (snd p) (snd q)

%{
%align 20

> ordop :: Ordering -> Ordering -> Ordering
> ordop x y = case x of 
>               EQ -> y
>               _  -> x

%align
%}


%if not codeOnly && variants

Possible variants:
%*** these do not take constant values into account

< fcompare :: Bifunctor f => (a->a->Ordering) -> (b->b->Ordering) -> 
<                            f a b -> f a b -> Ordering
< fcompare f g x y = 
<   maybe (compare (fconstructor2Int x) (fconstructor2Int y))                
<         (forder . fmap2 (uncurry f) (uncurry g))                           
<         (fzip (x,y))                                        
< 
< forder :: Bifunctor f => f Ordering Ordering -> Ordering
< forder = fcrush ordop EQ
< forder = foldr ordop EQ . fl_all
< 
< pcompare op x y = 
<   pzipWith' forder
<             (uncurry compare . (constructor2Int -*- constructor2Int)) 
<             (uncurry op) 
<             (x,y)

< ordop :: Ordering -> Ordering -> Ordering
< ordop x y = case x of 
<               EQ -> y
<               _  -> x

%endif not codeOnly && variants

