---------------------------------------------------------------
-- Zip functions
---  980409 Patrik Jansson
---------------------------------------------------------------
module Zip(pzip,fzip,pzipWith,pzipWith',(@@)) where
import Base(pmap,fmap,(-+-),(-*-))
import Propagate(fprop,sumprop,prodprop,propagate,mapMaybe)
-- Maybe could be replaced by any MonadZero

-- pzip :: Regular d => (d a,d b) -> Maybe (d (a,b))
pzip  =  ( (resultM.inn) @@ (fprop.fmap resultM pzip) @@ fzip )
      .  (out -*- out)

-- punzip :: Regular d => d (a,b) -> (d a,d b)
punzip x = (pmap fst x, pmap snd x)

-- pzipWith' :: Regular d => (FunctorOf d c e -> e) -> 
--                           ((d a,d b)->e) -> 
--                           ((a,b)->c) -> (d a,d b) -> e
pzipWith' ins fail op (x,y)  =
  maybe (fail (x,y)) (ins . fmap op (pzipWith' ins fail op)) 
        (fzip (out x, out y))

-- pzipWith :: Regular d => ((a, b) -> Maybe c) -> (d a, d b) -> Maybe (d c)
pzipWith  = pzipWith' (mapMaybe inn.fprop) (const zeroM)

-- funzip :: Bifunctor f => f (a,c) (b,d) -> (f a b,f c d)
funzip x = (fmap fst fst x, fmap snd snd x)

-- Bifunctor f => ...
polytypic fzip :: (f a b,f c d) -> Maybe (f (a,c) (b,d))
  = case f of
      g + h     ->  (sumprop   . (fzip -+- fzip)) @@ sumzip
      g * h     ->  (prodprop  . (fzip -*- fzip)) @@ prodzip
      Empty     ->  const (resultM ())
      Par       ->  resultM
      Rec       ->  resultM
      d @ g     ->  (propagate . (pmap fzip)    ) @@ pzip
      Const t   ->  constzip


--sumzip ::(Either a b,Either c d)-> Maybe (Either (a,c) (b,d))
sumzip p = case p of
	     (Left s ,Left t ) -> resultM (Left (s,t))
	     (Right s,Right t) -> resultM (Right (s,t))
	     _                 -> zeroM

--prodzip :: ((a,b),(c,d)) -> Maybe ((a,c),(b,d))
prodzip ((x,y),(s,t))  =  resultM ((x,s),(y,t))

-- should be
--   constzip :: Eq t => (t,t) -> Maybe t
--   constzip (x,y) = if x==y then resultM x else zeroM
-- but this requires an inexpressible type of fzip
constzip (x,y) = resultM x

{-
  Maybe monad functions
-}
--zeroM :: Maybe a
zeroM = Nothing

--resultM  :: a -> Maybe a
resultM x  =  Just x

--bindM    :: Maybe a -> (a -> Maybe b) -> Maybe b
bindM x f  =  maybe Nothing f x

--(@@)     :: (a -> Maybe b) -> (c -> Maybe a) -> c -> Maybe b
(g @@ f) a =  f a `bindM` g

