%% Literate PolyP + LaTeX script for use with lhs2TeX -*- Mode: latex; -*-
% ------------------------------------------------------------
% ConstructorName
%   990602 Patrik Jansson
% ------------------------------------------------------------

> module ConstructorName where

Functions |datatypeName| and |fconstructorName| are built in.

> datatypeName :: Regular d => d a -> String
> fconstructorName :: Bifunctor f => f a b -> String
> constructorName :: Regular d => d a -> String
> constructorName = fconstructorName . out

> constructorNames :: Regular d => d a -> [String]
> constructorNames = fconstructorNames . out
> 
> fconstructorNames :: Bifunctor f => f a b -> [String]
> fconstructorNames x =
>   map fconstructorName (fconstructors `asTypeOf` [x])

The use of |asTypeOf| is a way to propagate type information to the
correct destination. It is used to work around the lack of explicit
functor arguments.

> constructorNamesAndArities :: Regular d => d a -> [(String,Int)]
> constructorNamesAndArities = fconstructorNamesAndArities . out
> 
> fconstructorNamesAndArities :: Bifunctor f => f a b -> [(String,Int)]
> fconstructorNamesAndArities x = 
>   map (mapFst fconstructorName) 
>       (fconstructorsAndArities `asTypeOf`  [(x,undefined)])

%{
%align 14

> constructors  :: Regular d => [d a]
> constructors  =  map inn fconstructors
> 
> polytypic fconstructors :: [f a b] =
>   case f of 
>     g + h  ->  map Left fconstructors ++ map Right fconstructors
>     g      ->  [undefined]
> 
> polytypic fconstructorsAndArities :: [(f a b,Int)] =
>   case f of 
>     g + h  ->  map (mapFst Left) fconstructorsAndArities ++ 
>                map (mapFst Right) fconstructorsAndArities
>     g      ->  (\x -> [(x,fconstructorArity x)]) undefined
> 
> polytypic fconstructorArity :: f a b -> Int =
>   case f of
>     g * h  ->  \p-> fconstructorArity (fst p) + 
>                     fconstructorArity (snd p)
>     Empty  ->  const 0
>     f      ->  const 1

> constructor2Int :: Regular d => d a -> Int
> constructor2Int = fconstructor2Int . out
> 
> polytypic fconstructor2Int :: f a b -> Int =
>   case f of 
>     g + h  ->  const 0 `either` ((\ n -> 1 + n) . fconstructor2Int)
>     g      ->  const 0

%align
%}

> int2constructor :: Regular d => Int -> d a
> int2constructor n = constructors !! n
> 
> int2fconstructor :: Bifunctor f => Int -> f a b
> int2fconstructor n = fconstructors !! n

> mapFst :: (a->b) -> (a,c) -> (b,c)
> mapFst f p = (f (fst p), snd p)

