<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>PolyP reference manual</title>
</head>

<body>
<h1>PolyP reference manual</h1>

This text is a reference manual for PolyP.
(Patrik Jansson, 1998)


<h2>Compiler phases</h2>

Invoking the compiler phases:

<pre>
  chase [-i ImportDir] PolyPModule.phs  &gt; PolyPcode.Phs

  polyp [-p ExplTypes.hs] PolyPcode.Phs &gt; Haskellcode.Hs

  [cat Prefix.hs Haskellcode.Hs         &gt; Haskellcode.hs]
</pre>

The import chaser <CODE>chase</CODE> takes a polytypic program module
and inlines the text of all imported modules (recursively).

The output consists of one big module of the concatenated texts of the
involved modules and should normally be directed to a file (ending in
.Phs - a big 'P' to denote a big PolyP file).

If your input consists of just one file and does not need any others
the <code>chase</code> is unnecessary.

(But unless you paste the polytypic prelude into your file by hand,
 you will virtually always need <code>chase</code>.)

The flag <code>-i</code> can be used (any number of times) to specify
directories that are to be searched for the imported modules.

The polytypic library directory <code>POLYPDIR/polylib</code> is a
typical candidate here.

<h2>The main translation phase</h2>

The main compilation (or translation) is done by calling <code>polyp
P.Phs</code>.

It type checks the input file <code>P.Phs</code> and generates the
instances of all polytypic functions that are used in the code
reachable from <code>main</code>.

The output is Haskell code and can be loaded in hugs or compiled with
a Haskell compiler.

Sometimes the generated code is rejected as a Haskell program due to
the lack of explicit type declarations of top level overloaded
function.

In this case these declarations have to be supplied by hand.

The simplest way to do this is to put them in a separate file and then
<code>cat</code> it together with the <code>polyp</code> output.

If the flag -v (verbose) is used, the different phases of the PolyP
compilation give progress reports in a Haskell comment in the output
file:

<ul>

  <li>the parser reports the names of the successfully parsed
      declarations,

  <li>the dependency analysis reports a dependency ordered list of
      groups of mutually recursive declarations,

  <li>the type checker reports the types of all top level declarations

  <li>and the instance generation just reports the generated code.

</ul>

The error messages from PolyP unfortunately don't give line numbers
where the error occurred, but it is often possible to pinpoint the
location quite accurately by studying the reports:

If a type error occurs, check to see what function is the last one
before the error in the type report and look up the name following
this one in the dependency report. This definition is probably the
culprit.

<p>

The flag <code>-p</code> is used when you want to use Haskell
functions that are not in the built in part of the Haskell prelude.

If you list the types of these functions in a file
<code>ExplTypes.hs</code> and call PolyP with <code>polyp -p
ExplTypes.hs PolyPCode.Phs</code> you can use the listed functions in
the definitions in <code>PolyPCode.Phs</code>.

Note that the file <code>ExplTypes.hs</code> must contain only
explicit type declarations, and that these are only read by PolyP, not
included in the output.

The definitions of these functions should be placed in a separate file
and prepended to the PolyP output or loaded in hugs in some other way.

<h2>Polytypic program construction tips</h2>

When writing polytypic programs with PolyP there are some things to
think about:

<ul>

  <li>Try to separate the essentially polytypic part from the pure
      Haskell parts.

      This helps by keeping the PolyP input small thus simplifying
      debugging and by giving you the full power of Haskell to write
      the non-polytypic part, instead of the restricted subset that
      PolyP can handle.

      The way to achieve the separation in practice is to work with
      some Haskell files, some polytypic files and one file containing
      explicit type declarations of the Haskell definitions needed in
      the polytypic part. If these types are collected in the file
      <code>Types.hs</code>, invoke PolyP by <code>polyp -p Types.hs
      Code.Phs</code>.

  <li>Use as few <code>polytypic</code> constructs as possible.

      The <code>polytypic</code> construct is powerful, but difficult
      to use. 

      Often one more general polytypic function can solve a number of
      related polytypic problems given different parameters.

  <li>Use the polytypic library PolyLib.

      Code reuse is always very often possible with this supply of
      generic combinators.

      Using these predefined definitions in your code makes it
      shorter, and easier to read as the function names are more well
      known.

</ul>


<hr>
<!-- hhmts start -->
Last modified: Tue May 11 13:03:44 CEST 1999
<!-- hhmts end -->
by
<address>
<a href="http://www.cs.chalmers.se/~patrikj/"
 >Patrik Jansson</a> /
<a href="mailto:patrikj@cs.chalmers.se"
               >patrikj@cs.chalmers.se</a>
</address>
</body>
</html>
